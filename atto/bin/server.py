#!/usr/bin/env python

import logging
import msgpack
import inspect
import os
import sys
import time
import zmq
import zmq.auth
from zmq.auth.thread import ThreadAuthenticator

import util
import util.config
import plugins
from daemon import Daemon
logger = logging.getLogger()



class Server(Daemon):
    def load_plugins(self):
        self.plugs = {}
        for name, obj in inspect.getmembers(plugins):
            if 'Plugin' in name and inspect.isclass(obj):
                self.plugs[obj._name] = obj.decode
        logger.info("%s", self.plugs)

    def handle_msg(self, msg):
        logger.info("Handling Message")
        raw = msgpack.unpackb(msg)
        logger.info('Recieved %s msg', raw['name'])
        self.plugs[raw['name']](raw)
        #logger.info("Got Data %s", msgpack.unpackb(raw['data']))

    def run(self):
        ''' Run Ironhouse example '''

        # These directories are generated by the generate_certificates script
        keys_dir = self.config['certs']['certs']
        public_keys_dir = self.config['certs']['public']
        secret_keys_dir = self.config['certs']['private']
        if not (util.check_dir(keys_dir) and util.check_dir(public_keys_dir) and util.check_dir(secret_keys_dir)):
            logging.critical("Certificates are missing - run generate_certificates.py script first")
            sys.exit(1)
        logger.info("Keys: %s  |  Public: %s  |  Secret: %s", keys_dir, public_keys_dir, secret_keys_dir)

        ctx = zmq.Context.instance()

        # Start an authenticator for this context.
        auth = ThreadAuthenticator(ctx)
        auth.start()
        for ip in self.config['server']['auth']:
            auth.allow(ip)

        # Tell authenticator to use the certificate in a directory
        auth.configure_curve(domain='*', location=public_keys_dir)

        server = ctx.socket(zmq.REP)

        server_secret_file = os.path.join(secret_keys_dir, "server.key_secret")
        server_public, server_secret = zmq.auth.load_certificate(server_secret_file)
        server.curve_secretkey = server_secret
        server.curve_publickey = server_public
        server.curve_server = True  # must come before bind
        bind_info = 'tcp://%s:%s' % (self.config['server']['listen'], self.config['server']['port'])
        server.bind(bind_info)
        logger.info("Server bound to: %s", bind_info)

        logger.info("Starting reciever.")
        self.load_plugins()

        logger.info("Starting reciever.")
        while True:
            msg = server.recv()
            self.handle_msg(msg)
            server.send("ack")
            #time.sleep(self.config['server']['sleep']/1000)
            #self.check_config()

        # stop auth thread
        auth.stop()

if __name__ == '__main__':
    if zmq.zmq_version_info() < (4,0):
        raise RuntimeError("Security is not supported in libzmq version < 4.0. libzmq version {0}".format(zmq.zmq_version()))

    config = util.load_yaml_file(util.config.SERVER["config"])
    util.init_logging(**config['logging'])
    daemon = Server(config['pid_file'], config_file=util.config.SERVER["config"])
    logger.info("Started Server")
    daemon.run()
    if len(sys.argv) == 2:
        if 'start' == sys.argv[1]:
            daemon.start()
        elif 'stop' == sys.argv[1]:
            daemon.stop()
        elif 'restart' == sys.argv[1]:
            daemon.restart()
        else:
            print "Unknown command"
            sys.exit(2)
        sys.exit(0)
    else:
        print "usage: %s start|stop|restart" % sys.argv[0]
        sys.exit(2)


