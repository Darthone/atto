#!/usr/bin/env python

import logging
import os
import sys

import zmq
import zmq.auth
from zmq.auth.thread import ThreadAuthenticator
import time

import util
import util.config
import plugins
from daemon import Daemon

logger = logging.getLogger()

class Client(Daemon):
    def load_plugins(self):
        self.plugs = [plugins.CPUPlugin()]

    def run(self):
        # These directories are generated by the generate_certificates script
        keys_dir = self.config['certs']['certs']                                                                  
        public_keys_dir = self.config['certs']['public']                                                          
        secret_keys_dir = self.config['certs']['private']                                                         
        if not (util.check_dir(keys_dir) and util.check_dir(public_keys_dir) and util.check_dir(secret_keys_dir)):
            logging.critical("Certificates are missing - run generate_certificates.py script first")              
            sys.exit(1)                                                                                           
        logger.info("Keys: %s  |  Public: %s  |  Secret: %s", keys_dir, public_keys_dir, secret_keys_dir)         
                                                                                                                  
        ctx = zmq.Context.instance()                                                                              

        # Start an authenticator for this context.
        auth = ThreadAuthenticator(ctx)
        auth.start()
        auth.allow(self.config['client']['auth'])
        # Tell authenticator to use the certificate in a directory
        auth.configure_curve(domain='*', location=public_keys_dir)

        client = ctx.socket(zmq.REQ)
        client.RCVTIMEO = self.config['client']['timeout']

        # We need two certificates, one for the client and one for
        # the server. The client must know the server's public key
        # to make a CURVE connection.
        client_secret_file = os.path.join(secret_keys_dir, "client.key_secret")
        client_public, client_secret = zmq.auth.load_certificate(client_secret_file)
        client.curve_secretkey = client_secret
        client.curve_publickey = client_public

        server_public_file = os.path.join(public_keys_dir, "server.key")
        server_public, _ = zmq.auth.load_certificate(server_public_file)
        # The client must know the server's public key to make a CURVE connection.
        client.curve_serverkey = server_public
        connection_str = 'tcp://%s:%s' % (self.config['client']['dest'], self.config['client']['port'])
        logger.info("Trying to connect to %s", connection_str)
        client.connect(connection_str)

        logger.info("Loading plguins")
        self.load_plugins()
        logger.info("Starting Loop")
        while True:
            try:
                for p in self.plugs:
                    logging.info("Running %s", p._name)
                    client.send(p.encode())
                    logging.debug("Waiting for ack")
                    message = client.recv()
                    logging.info("Recieved ack")
                time.sleep(self.config['client']['sleep']/1000)
                self.check_config()

            except zmq.error.ZMQError as e:
                logger.critical("ZMQError, Exiting: %s", e)
                exit()

        # stop auth thread
        auth.stop()

if __name__ == '__main__':
    if zmq.zmq_version_info() < (4,0):
        raise RuntimeError("Security is not supported in libzmq version < 4.0. libzmq version {0}".format(zmq.zmq_version()))
    config = util.load_yaml_file(util.config.CLIENT["config"])
    util.init_logging(**config['logging'])
    daemon = Client(config['pid_file'], config_file=util.config.CLIENT["config"])
    daemon.run()
    if len(sys.argv) == 2:
        if 'start' == sys.argv[1]:
            daemon.start()
        elif 'stop' == sys.argv[1]:
            daemon.stop()
        elif 'restart' == sys.argv[1]:
            daemon.restart()
        else:
            print "Unknown command"
            sys.exit(2)
        sys.exit(0)
    else:
        print "usage: %s start|stop|restart" % sys.argv[0]
        sys.exit(2)


